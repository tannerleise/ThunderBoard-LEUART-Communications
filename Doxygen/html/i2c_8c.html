<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.2"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>LEUART Lab: src/Source Files/i2c.c File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">LEUART Lab
   </div>
   <div id="projectbrief">Uses the leuart to communicate with the ble blutooth module.</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.2 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search",'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="dir_68267d1309a1af8e8297ef4c3efbcdba.html">src</a></li><li class="navelem"><a class="el" href="dir_c9e40434d11e5548a56e3b283ebc6198.html">Source Files</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle"><div class="title">i2c.c File Reference</div></div>
</div><!--header-->
<div class="contents">

<p>Generic Driver for i2c.  
<a href="#details">More...</a></p>
<div class="textblock"><code>#include &quot;i2c.h&quot;</code><br />
</div><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a8b9e3d6ce8897ee906985fe6200a03bd"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="i2c_8c.html#a8b9e3d6ce8897ee906985fe6200a03bd">ack_func</a> (<a class="el" href="struct_i2_c___s_t_a_t_e___m_a_c_h_i_n_e.html">I2C_STATE_MACHINE</a> *i2c_sm)</td></tr>
<tr class="memdesc:a8b9e3d6ce8897ee906985fe6200a03bd"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is the function handler for when an ack interrupt is received.  <a href="i2c_8c.html#a8b9e3d6ce8897ee906985fe6200a03bd">More...</a><br /></td></tr>
<tr class="separator:a8b9e3d6ce8897ee906985fe6200a03bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a23c36e4dfcbccb7702335c1326aca838"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="i2c_8c.html#a23c36e4dfcbccb7702335c1326aca838">rxdatav_func</a> (<a class="el" href="struct_i2_c___s_t_a_t_e___m_a_c_h_i_n_e.html">I2C_STATE_MACHINE</a> *i2c_sm)</td></tr>
<tr class="memdesc:a23c36e4dfcbccb7702335c1326aca838"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is the function handler for when an rxdatav interrupt is received.  <a href="i2c_8c.html#a23c36e4dfcbccb7702335c1326aca838">More...</a><br /></td></tr>
<tr class="separator:a23c36e4dfcbccb7702335c1326aca838"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade1a523e0b1adf619c88ce357fe3274f"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="i2c_8c.html#ade1a523e0b1adf619c88ce357fe3274f">stop_func</a> (<a class="el" href="struct_i2_c___s_t_a_t_e___m_a_c_h_i_n_e.html">I2C_STATE_MACHINE</a> *i2c_sm)</td></tr>
<tr class="memdesc:ade1a523e0b1adf619c88ce357fe3274f"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is the function handler for when an stop interrupt is received.  <a href="i2c_8c.html#ade1a523e0b1adf619c88ce357fe3274f">More...</a><br /></td></tr>
<tr class="separator:ade1a523e0b1adf619c88ce357fe3274f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d74e3a730c761f8adad646b4c696df6"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="i2c_8c.html#a3d74e3a730c761f8adad646b4c696df6">i2c_bus_reset</a> (I2C_TypeDef *i2c)</td></tr>
<tr class="memdesc:a3d74e3a730c761f8adad646b4c696df6"><td class="mdescLeft">&#160;</td><td class="mdescRight">This resets the i2c bus.  <a href="i2c_8c.html#a3d74e3a730c761f8adad646b4c696df6">More...</a><br /></td></tr>
<tr class="separator:a3d74e3a730c761f8adad646b4c696df6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade5ff4ae0d40da2406444631232bd293"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="i2c_8c.html#ade5ff4ae0d40da2406444631232bd293">i2c_open</a> (I2C_TypeDef *i2c, <a class="el" href="struct_i2_c___o_p_e_n___s_t_r_u_c_t.html">I2C_OPEN_STRUCT</a> *i2c_init)</td></tr>
<tr class="memdesc:ade5ff4ae0d40da2406444631232bd293"><td class="mdescLeft">&#160;</td><td class="mdescRight">this enables the clock for i2c and sets a local type def which is input into function  <a href="i2c_8c.html#ade5ff4ae0d40da2406444631232bd293">More...</a><br /></td></tr>
<tr class="separator:ade5ff4ae0d40da2406444631232bd293"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6434164b1cf02d865ac9d70bd256e0e8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="i2c_8c.html#a6434164b1cf02d865ac9d70bd256e0e8">i2c_start</a> (bool mode, uint32_t *data, uint32_t bytes_expected, uint32_t device_address, uint32_t register_address, I2C_TypeDef *i2cx, uint32_t call_back)</td></tr>
<tr class="memdesc:a6434164b1cf02d865ac9d70bd256e0e8"><td class="mdescLeft">&#160;</td><td class="mdescRight">sets up the i2c for the device needed  <a href="i2c_8c.html#a6434164b1cf02d865ac9d70bd256e0e8">More...</a><br /></td></tr>
<tr class="separator:a6434164b1cf02d865ac9d70bd256e0e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee17b4120877dd62ce1800d413e329b5"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="i2c_8c.html#aee17b4120877dd62ce1800d413e329b5">is_available</a> (I2C_TypeDef *i2c)</td></tr>
<tr class="memdesc:aee17b4120877dd62ce1800d413e329b5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if the i2c is available.  <a href="i2c_8c.html#aee17b4120877dd62ce1800d413e329b5">More...</a><br /></td></tr>
<tr class="separator:aee17b4120877dd62ce1800d413e329b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a906df0c8802c3aac9ccbb74b11716920"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="i2c_8c.html#a906df0c8802c3aac9ccbb74b11716920">I2C0_IRQHandler</a> ()</td></tr>
<tr class="memdesc:a906df0c8802c3aac9ccbb74b11716920"><td class="mdescLeft">&#160;</td><td class="mdescRight">The IRQ handler for i2c0.  <a href="i2c_8c.html#a906df0c8802c3aac9ccbb74b11716920">More...</a><br /></td></tr>
<tr class="separator:a906df0c8802c3aac9ccbb74b11716920"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e0ce3354daaf3dc2912dd9e7b70260d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="i2c_8c.html#a6e0ce3354daaf3dc2912dd9e7b70260d">I2C1_IRQHandler</a> ()</td></tr>
<tr class="memdesc:a6e0ce3354daaf3dc2912dd9e7b70260d"><td class="mdescLeft">&#160;</td><td class="mdescRight">The IRQ handler for i2c1.  <a href="i2c_8c.html#a6e0ce3354daaf3dc2912dd9e7b70260d">More...</a><br /></td></tr>
<tr class="separator:a6e0ce3354daaf3dc2912dd9e7b70260d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="var-members" name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:a72191069cd54a8d558630741362c6354"><td class="memItemLeft" align="right" valign="top"><a id="a72191069cd54a8d558630741362c6354" name="a72191069cd54a8d558630741362c6354"></a>
static <a class="el" href="struct_i2_c___s_t_a_t_e___m_a_c_h_i_n_e.html">I2C_STATE_MACHINE</a>&#160;</td><td class="memItemRight" valign="bottom"><b>i2c0_state</b></td></tr>
<tr class="separator:a72191069cd54a8d558630741362c6354"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a215eaaaad8bb63b3658c77f6a0a7f6f9"><td class="memItemLeft" align="right" valign="top"><a id="a215eaaaad8bb63b3658c77f6a0a7f6f9" name="a215eaaaad8bb63b3658c77f6a0a7f6f9"></a>
static <a class="el" href="struct_i2_c___s_t_a_t_e___m_a_c_h_i_n_e.html">I2C_STATE_MACHINE</a>&#160;</td><td class="memItemRight" valign="bottom"><b>i2c1_state</b></td></tr>
<tr class="separator:a215eaaaad8bb63b3658c77f6a0a7f6f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p >Generic Driver for i2c. </p>
<p ><a class="el" href="i2c_8c.html" title="Generic Driver for i2c.">i2c.c</a> </p><dl class="section author"><dt>Author</dt><dd>Tanner Leise </dd></dl>
<dl class="section date"><dt>Date</dt><dd>9/28/21 </dd></dl>
</div><h2 class="groupheader">Function Documentation</h2>
<a id="a8b9e3d6ce8897ee906985fe6200a03bd" name="a8b9e3d6ce8897ee906985fe6200a03bd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8b9e3d6ce8897ee906985fe6200a03bd">&#9670;&nbsp;</a></span>ack_func()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void ack_func </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_i2_c___s_t_a_t_e___m_a_c_h_i_n_e.html">I2C_STATE_MACHINE</a> *&#160;</td>
          <td class="paramname"><em>i2c_sm</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This is the function handler for when an ack interrupt is received. </p>
<p >this is a state machine that handles the ack interrupt. If we are in the state initialize_write of our state machine, then we are going to send the register address and set to the next state communicate state.</p>
<p >If in communicate state, then we are going to send a start command, send a write command with the device_address. Then we are going to increment the state to initialize read.</p>
<dl class="section note"><dt>Note</dt><dd>called when ack interrupts</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname"><a class="el" href="struct_i2_c___s_t_a_t_e___m_a_c_h_i_n_e.html">I2C_STATE_MACHINE</a></td><td>*i2c_sm Holds information needed for the state machine </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a906df0c8802c3aac9ccbb74b11716920" name="a906df0c8802c3aac9ccbb74b11716920"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a906df0c8802c3aac9ccbb74b11716920">&#9670;&nbsp;</a></span>I2C0_IRQHandler()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void I2C0_IRQHandler </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The IRQ handler for i2c0. </p>
<p >This checks whether an ack, rxdatav, or stop interrupt wasa triggered, then sends us to the function handler.</p>
<dl class="section note"><dt>Note</dt><dd>Used to properly guide the state machine. </dd></dl>

</div>
</div>
<a id="a6e0ce3354daaf3dc2912dd9e7b70260d" name="a6e0ce3354daaf3dc2912dd9e7b70260d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6e0ce3354daaf3dc2912dd9e7b70260d">&#9670;&nbsp;</a></span>I2C1_IRQHandler()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void I2C1_IRQHandler </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The IRQ handler for i2c1. </p>
<p >This checks whether an ack, rxdatav, or stop interrupt wasa triggered, then sends us to the function handler.</p>
<dl class="section note"><dt>Note</dt><dd>Used to properly guide the state machine. </dd></dl>

</div>
</div>
<a id="a3d74e3a730c761f8adad646b4c696df6" name="a3d74e3a730c761f8adad646b4c696df6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3d74e3a730c761f8adad646b4c696df6">&#9670;&nbsp;</a></span>i2c_bus_reset()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void i2c_bus_reset </td>
          <td>(</td>
          <td class="paramtype">I2C_TypeDef *&#160;</td>
          <td class="paramname"><em>i2c</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This resets the i2c bus. </p>
<p >resets the i2c peripheral state machine, saves the state of interrupts then clears the flags and buffers. It then sends a stat and stop command in accordance to the data sheet.</p>
<dl class="section note"><dt>Note</dt><dd>called in i2c open</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">I2C_TypeDef</td><td>*i2c This typedef is specific to I2C0 or I2C1 </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ade5ff4ae0d40da2406444631232bd293" name="ade5ff4ae0d40da2406444631232bd293"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ade5ff4ae0d40da2406444631232bd293">&#9670;&nbsp;</a></span>i2c_open()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void i2c_open </td>
          <td>(</td>
          <td class="paramtype">I2C_TypeDef *&#160;</td>
          <td class="paramname"><em>i2c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_i2_c___o_p_e_n___s_t_r_u_c_t.html">I2C_OPEN_STRUCT</a> *&#160;</td>
          <td class="paramname"><em>i2c_init</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>this enables the clock for i2c and sets a local type def which is input into function </p>
<p >Checks for the i2c input and sets the i2c accordingly. we then set the local type def to the values input to the function. We then set the route locations and enable interrupts int IEN and the NVIC.</p>
<dl class="section note"><dt>Note</dt><dd>Called in si1133_i2c_open</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">I2C_TypeDef</td><td>*i2c This typedef is specific to I2C0 or I2C1</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname"><a class="el" href="struct_i2_c___o_p_e_n___s_t_r_u_c_t.html">I2C_OPEN_STRUCT</a></td><td>*i2c_init Holds information needed for the state machine </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a6434164b1cf02d865ac9d70bd256e0e8" name="a6434164b1cf02d865ac9d70bd256e0e8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6434164b1cf02d865ac9d70bd256e0e8">&#9670;&nbsp;</a></span>i2c_start()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void i2c_start </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>mode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>bytes_expected</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>device_address</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>register_address</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">I2C_TypeDef *&#160;</td>
          <td class="paramname"><em>i2cx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>call_back</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>sets up the i2c for the device needed </p>
<p >Checks what I2C was input into the function then sets a local pointer equal to that. We then block sleep mode and set availability to false.After, we set up the local <a class="el" href="struct_i2_c___s_t_a_t_e___m_a_c_h_i_n_e.html">I2C_STATE_MACHINE</a> variable to the input values and set values for the i2c. We then set the current state to initialize write. Finally we send a start command to the i2c and then send the device address and then send a write command since the i2c always starts out writing.</p>
<dl class="section note"><dt>Note</dt><dd>Called in Si1133_read</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">bool</td><td>mode This tells us if we are reading or writing.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">uint32_t</td><td>*data This is the variable used to hold the data.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">uint32_t</td><td>bytes_expected This is how many bytes we expect.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">uint32_t</td><td>device_address This is the device address we are talking to.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">uint32_t</td><td>register_address The register we are communicating with.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">I2C_TypeDef</td><td>*i2cx This is the i2c we are using, either I2C1 or I2C0.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">uint32_t</td><td>call_back This is the call back function we are using. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aee17b4120877dd62ce1800d413e329b5" name="aee17b4120877dd62ce1800d413e329b5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aee17b4120877dd62ce1800d413e329b5">&#9670;&nbsp;</a></span>is_available()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool is_available </td>
          <td>(</td>
          <td class="paramtype">I2C_TypeDef *&#160;</td>
          <td class="paramname"><em>i2c</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if the i2c is available. </p>
<p >takes in which i2c used, returns the whether or not the i2c is available.</p>
<dl class="section note"><dt>Note</dt><dd>used multiple times in si1133_config. </dd></dl>

</div>
</div>
<a id="a23c36e4dfcbccb7702335c1326aca838" name="a23c36e4dfcbccb7702335c1326aca838"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a23c36e4dfcbccb7702335c1326aca838">&#9670;&nbsp;</a></span>rxdatav_func()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void rxdatav_func </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_i2_c___s_t_a_t_e___m_a_c_h_i_n_e.html">I2C_STATE_MACHINE</a> *&#160;</td>
          <td class="paramname"><em>i2c_sm</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This is the function handler for when an rxdatav interrupt is received. </p>
<p >this is a state machine that handles the rxdatav interrupt. If we are in the state initialize_read, then we are going to decrement the bytes expected, clear the data variable which is a member of the i2c sm input into the function. We then set the data member equal to the data in the RXdata. If the bytes expected is not equal to 0 then we send an ack to the device and dont change states. If we got all the bytes expected, then we send a nack, stop command, then move to the reveive data state.</p>
<dl class="section note"><dt>Note</dt><dd>called when rxdatav interrupts</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname"><a class="el" href="struct_i2_c___s_t_a_t_e___m_a_c_h_i_n_e.html">I2C_STATE_MACHINE</a></td><td>*i2c_sm Holds information needed for the state machine </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ade1a523e0b1adf619c88ce357fe3274f" name="ade1a523e0b1adf619c88ce357fe3274f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ade1a523e0b1adf619c88ce357fe3274f">&#9670;&nbsp;</a></span>stop_func()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void stop_func </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_i2_c___s_t_a_t_e___m_a_c_h_i_n_e.html">I2C_STATE_MACHINE</a> *&#160;</td>
          <td class="paramname"><em>i2c_sm</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This is the function handler for when an stop interrupt is received. </p>
<p >this is a state machine that handles the stop interrupt. When this is recieved we unblock sleep, set the gecko to available, set the state back to initialize_write, then finally add the i2c_callback.</p>
<dl class="section note"><dt>Note</dt><dd>called when stop interrupts</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname"><a class="el" href="struct_i2_c___s_t_a_t_e___m_a_c_h_i_n_e.html">I2C_STATE_MACHINE</a></td><td>*i2c_sm Holds information needed for the state machine </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.2
</small></address>
</body>
</html>
